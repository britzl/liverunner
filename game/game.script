go.property("speed", 500)
go.property("distance", 0)

local flow = require "ludobits.m.flow"
local level_data = require "game.level_data"

local WIDTH = sys.get_config("display.width")
local HEIGHT = sys.get_config("display.height")

function init(self)
	math.randomseed(os.time())
	self.objects = {}
	self.current_level_proxy = nil
	self.level = 1
	self.levels = {
		{ proxy = nil },
		{ proxy = "levels#level2" },
		{ proxy = "levels#level3" },
	}

	msg.post("level1/level1", "initial_spawn")
--[[	self.objects = {}
	for layer_id, layer in pairs(level_data) do
		self.objects[layer_id] = {}
		local data = layer[self.level]
		local pos = vmath.vector3(0, data.y, data.z)
		for i=1,data.amount do
			local id = factory.create(data.factory, nil, nil, { anim_id = data.sprites[math.random(1, #data.sprites)] })
			local size = go.get(msg.url(nil, id, "sprite"), "size")
			data.width = size.x
			go.set_position(pos, id)
			pos.x = pos.x + data.width + math.random(data.spacing.min, data.spacing.max)
			pos.y = data.y + math.random(data.y_variation.min, data.y_variation.max)
			table.insert(self.objects[layer_id], id)
		end
	end--]]
	
	go.animate("camera", "euler.z", go.PLAYBACK_LOOP_PINGPONG, -10, go.EASING_INOUTQUAD, 250)
	go.animate("camera", "position.y", go.PLAYBACK_LOOP_PINGPONG, 60, go.EASING_INOUTQUAD, 250)
	
	self.dt = 0.0167
	flow(function()
		while true do
			self.speed = 500
			self.distance = 25
			while self.distance > 0 do
				self.speed = math.min(self.speed + 10 * self.dt, 1000)
				self.distance = math.max(0, self.distance - (self.speed * self.dt * 0.025))
				flow.frames(1)
			end
			go.animate("#", "speed", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, 5)
			while self.speed > 150 do
				flow.frames(1)
			end
			msg.post("player/player", "walk")
			while self.speed > 0 do
				flow.frames(1)
			end
			msg.post("player/player", "idle")
			flow.delay(1)
			
			print("level completed", self.level)
			if self.current_level_proxy then
				print("unloading", self.current_level_proxy)
				flow.unload(self.current_level_proxy)
			end
			self.level = math.min(self.level + 1, #self.levels)
			print("next level", self.level)
			self.current_level_proxy = self.levels[self.level].proxy
			print("loading", self.current_level_proxy)
			flow.load(self.current_level_proxy)
			msg.post("player/player", "run")
		end
	end)
end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
end
local BG_COLOR = vmath.vector4(213/255, 237/255, 246/255, 1)

function update(self, dt)
	flow.update(dt)

	self.dt = dt

	msg.post("@render:", "clear_color", { color = BG_COLOR })
	msg.post("#hud", "update_distance", { distance = self.distance })
	
	--[[for layer_id,layer_objects in pairs(self.objects) do
		for i,object in pairs(layer_objects) do
			local pos = go.get_position(object)
			local size = go.get(msg.url(nil, object, "sprite"), "size")
			local speed = vmath.vector3(math.max(0, self.speed - (-pos.z * 250)), 0, 0)
			pos = pos - speed * dt
			go.set_position(pos, object)
			if pos.x < -size.x then
				go.delete(object)

				local layer_data = level_data[layer_id][self.level]
				if layer_data then
					pos.x = pos.x + (size.x + math.random(layer_data.spacing.min, layer_data.spacing.max)) * layer_data.amount
					pos.y = layer_data.y + math.random(layer_data.y_variation.min, layer_data.y_variation.max)
					pos.z = layer_data.z
					local id = factory.create(layer_data.factory, pos, nil, { anim_id = layer_data.sprites[math.random(1, #layer_data.sprites)] })
					layer_objects[i] = id
				else
					layer_objects[i] = nil
				end
			end
		end
	end--]]
end

function on_message(self, message_id, message, sender)
	flow.on_message(message_id, message, sender)
end

function on_input(self, action_id, action)
	-- Add input-handling code here
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end
